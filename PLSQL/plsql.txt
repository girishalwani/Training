begin
DBMS_OUTPUT.PUT_LINE('hello world');
end;
/;

-- DISPLAY THE BIG NUMBER OUT OF THREE
DECLARE
NUM1 NUMBER;
NUM2 NUMBER;
BEGIN
NUM1:=&NUM1;
NUM2:=&NUM2;
-- IF CONDITIONS 
IF NUM1 > NUM2 THEN
   DBMS_OUTPUT.PUT_LINE(NUM1);
ELSIF NUM2 > NUM1 THEN
   DBMS_OUTPUT.PUT_LINE(NUM2);
ELSE
   DBMS_OUTPUT.PUT_LINE('BOTH ARE SAME');
END IF;
END;
/

--looops---
DECLARE
NUM1 NUMBER;
BEGIN
NUM1:=1;
LOOP
DBMS_OUTPUT.PUT_LINE(NUM1);
NUM1:=NUM1+1;
EXIT WHEN NUM1 =10;
END LOOP;
END;
/


-- whilee loop --
DECLARE
NUM1 NUMBER;
BEGIN
NUM1:=1;
WHILE NUM1 < 10 LOOP
DBMS_OUTPUT.PUT_LINE(NUM1);
NUM1:=NUM1+1;
END LOOP;
END;
/



---for loop---

BEGIN
FOR NUM1 IN REVERSE 1..10 LOOP
IF MOD(NUM1,3)=0 THEN
DBMS_OUTPUT.PUT_LINE(NUM1);
END IF;
END LOOP;
END;
/


-- with string--
DECLARE
NAME VARCHAR2(10);
BEGIN
NAME := 'Welcome';
FOR NUM1 IN 1..length(name) LOOP
dbms_output.put_line(substr(name,num1,1));
END LOOP;
END;
/

--interacting with data bases
--select
--update
--insert
---delete
------ create alter and drop ddl..if we want to word we have to learn dynamic sql--

-- select 
DECLARE
NAME VARCHAR2(10);
pre_sal number;
NEW_SAL NUMBER;
BEGIN
NAME:='&ENAME';
NEW_SAL:=&NEWSAL;
SELECT SAL INTO PRE_SAL FROM EMP WHERE ENAME = NAME;
IF PRE_SAL<NEW_SAL THEN
UPDATE EMP SET SAL = NEW_SAL WHERE ENAME = NAME;
COMMIT;
DBMS_OUTPUT.PUT_LINE('THE SAL IS UPDATED');
ELSE
DBMS_OUTPUT.PUT_LINE('THE SAL IS NOT UPDATED');
END IF;
END;
/


-- select 
--%TYPE SINGLE VARIABLE 
--%ROWTYPE AL LTHE COL ROW TYPE 
--TABLE STRUCTURE WITH ALL THE COL NAME IN THE TABLE WILL DECLARED 
DECLARE
EMPROW EMP%ROWTYPE;
ENO EMP.EMPNO%TYPE;-- IT WILL SEE THE DATA TYPE AND SIZE IN THE TABLE THAT IS USED AND DECLARE THE SAME TYPE
BEGIN
ENO:=&EMPNO;
SELECT * INTO EMPROW FROM EMP WHERE EMPNO=ENO;
DBMS_OUTPUT.PUT_LINE('NAME IS '||EMPROW.ENAME||'JOB IS '||EMPROW.JOB);
END;
/

--procedure

CREATE OR REPLACE PROCEDURE ADD_NUM(NUM1 IN NUMBER,NUM2 IN  NUMBER,RES OUT NUMBER)
IS
BEGIN
RES:=NUM1 + NUM2;-- ADDING THE TOW VALUES PASSED FROM 
--DBMS_OUTPUT.PUT_LINE('THE RESULT IS '||RES);
END;

--execution
DECLARE
 R NUMBER;
 BEGIN
 ADD_NUM(34,34,R);
 DBMS_OUTPUT.PUT_LINE(R);
 END;
 /



----
CREATE OR REPLACE PROCEDURE ADD_NUM(NUM1 IN NUMBER,NUM2 IN OUT NUMBER)
IS
RES NUMBER;
BEGIN
RES:=NUM1 + NUM2;-- ADDING THE TOW VALUES PASSED FROM 
NUM2:=RES;
--DBMS_OUTPUT.PUT_LINE('THE RESULT IS '||RES);
END;


DECLARE
R NUMBER;
BEGIN
R:=40;
ADD_NUM(34,R);
DBMS_OUTPUT.PUT_LINE(R);
END;

-- cursor

DECLARE
NAME EMP.ENAME%TYPE;
CURSOR EMP_CUR IS SELECT ENAME FROM EMP;
BEGIN
OPEN EMP_CUR;
LOOP
FETCH EMP_CUR INTO NAME;
EXIT WHEN EMP_CUR%NOTFOUND;
DBMS_OUTPUT.PUT_LINE(NAME);
END LOOP;
CLOSE EMP_CUR;
END;


---rotype cursor
DECLARE
CURSOR EMP_CUR IS SELECT ENAME,DNAME,LOC,SAL,JOB FROM EMP NATURAL JOIN DEPT;
VAR_CUR EMP_CUR%ROWTYPE;
BEGIN
OPEN EMP_CUR;
LOOP
FETCH EMP_CUR INTO VAR_CUR;
EXIT WHEN EMP_CUR%NOTFOUND;
DBMS_OUTPUT.PUT_LINE(VAR_CUR.ENAME||' '||VAR_CUR.DNAME);
END LOOP;
CLOSE EMP_CUR;
END;
/



DECLARE
NEWSAL NUMBER;
NAME VARCHAR2(10);
BEGIN
NEWSAL:=&NEWSAL;
NAME:='&NAME';
UPDATE EMP SET SAL = NEWSAL WHERE ENAME = NAME;
IF SQL%ROWCOUNT>0 THEN
DBMS_OUTPUT.PUT_LINE('THE SAL IS UPDATED');
ELSE
DBMS_OUTPUT.PUT_LINE('THE SAL IS NOT UPDATED AS ENAME IS NOT MATCHING');
END IF;
END;
/

--isopen---foumd--not found

---parameterized cursor

DECLARE
EVAL EMP%ROWTYPE;
CURSOR CUR(DNO NUMBER) IS SELECT * FROM EMP WHERE DEPTNO = DNO;
BEGIN
OPEN CUR(10);
FETCH CUR INTO EVAL;
DBMS_OUTPUT.PUT_LINE(EVAL.ENAME||' '||EVAL.DEPTNO);
CLOSE CUR;
OPEN CUR(20);
FETCH CUR INTO EVAL;
DBMS_OUTPUT.PUT_LINE(EVAL.ENAME||' '||EVAL.DEPTNO);
END;
/

--dynamic cursor

DECLARE
TYPE REF_CUR_TYPE IS REF CURSOR;
REF_CUR REF_CUR_TYPE;
EVAL EMP%ROWTYPE;
DVAL DEPT%ROWTYPE;
BEGIN
OPEN REF_CUR FOR SELECT * FROM EMP;
FETCH REF_CUR INTO EVAL;
DBMS_OUTPUT.PUT_LINE(EVAL.ENAME);
CLOSE REF_CUR;
OPEN REF_CUR FOR SELECT * FROM DEPT;
FETCH REF_CUR INTO DVAL;
DBMS_OUTPUT.PUT_LINE(DVAL.DNAME);
CLOSE REF_CUR;
END;
/

--exception
declare
   num1 number;
   begin
   update emp set ename = 'jolly'
    where ename ='SMITH';
  DBMS_OUTPUT.PUT_LINE('THE REC IS UPDATED');
 SAVEPOINT MARK2;
  NUM1:=5/0;
  DBMS_OUTPUT.PUT_LINE('WELCOME');
  DBMS_OUTPUT.PUT_LINE('THIS WILL NOT WORK');
 COMMIT;
 EXCEPTION
 WHEN ZERO_DIVIDE THEN
  DBMS_OUTPUT.PUT_LINE('IT IS A ZERO DIVIDE');
 ROLLBACK TO MARK2;
 COMMIT;
   end;



  CREATE OR REPLACE PROCEDURE INS_DEPT(DNO NUMBER,DNM VARCHAR2,LC VARCHAR2)
   IS
   UNI_EXP EXCEPTION;
   ERNO CHAR(20);
   MSG VARCHAR2(100);
 ZERO_DIV EXCEPTION;
  NUM NUMBER;
  PRAGMA EXCEPTION_INIT(ZERO_DIV,-1476);
  PRAGMA EXCEPTION_INIT(UNI_EXP,-1);
   BEGIN
   INSERT INTO DEPT VALUES(DNO,DNM,LC);
   DBMS_OUTPUT.PUT_LINE('THE REC IS INSERTED');
   NUM:=3/0;
   EXCEPTION
  WHEN UNI_EXP THEN
   DBMS_OUTPUT.PUT_LINE('DUPLICATE DEPTNO ');
 WHEN ZERO_DIV THEN
   DBMS_OUTPUT.PUT_LINE('ZERO DIV ');
 WHEN OTHERS THEN
   DBMS_OUTPUT.PUT_LINE('SOME ERROR');
   ERNO:=SQLCODE;
   MSG:=SQLERRM;
   INSERT INTO ERR_LOG VALUES(ERNO,MSG);
   END;
 /


DECLARE
 NUM1 NUMBER;
 NUM2 NUMBER;
 RES NUMBER;
 EXP1 EXCEPTION;
 BEGIN
 NUM1:=&NUM1;
 NUM2:=&NUM2;
 IF NUM1 < NUM2 THEN
 RAISE EXP1;
 END IF;
 RES:=NUM1+NUM2;
 DBMS_OUTPUT.PUT_LINE(RES);
 EXCEPTION
 WHEN EXP1 THEN
 DBMS_OUTPUT.PUT_LINE('THE NUM1 > NUM2');
 END;



 CREATE [OR REPLACE] TRIGGER trigger name
2    {BEFORE | AFTER } { DDL event} ON {DATABASE | SCHEMA}
3    [WHEN (...)]
4    DECLARE
5    Variable declarations
6    BEGIN
7    ...some code...
8    END;


alter trigger name disable;

  1  CREATE OR REPLACE TRIGGER INSTEADOFTRIG
  2  INSTEAD OF INSERT ON V1
  3  DECLARE
  4  CNT NUMBER;
  5  BEGIN
  6  SELECT COUNT(*) INTO CNT FROM EMP WHERE DEPTNO =:NEW.DEPTNO;
  7  IF CNT = 0 THEN
  8  INSERT INTO DEPT VALUES(:NEW.DEPTNO,:NEW.DNAME,:NEW.LOC);
  9  END IF;
 10  INSERT INTO EMP(EMPNO,ENAME,DEPTNO) VALUES(:NEW.EMPNO,:NEW.ENAME,:NEW.DEPTN
O);
 11* END;
SQL> /










